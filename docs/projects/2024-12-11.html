<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Creating an Interpreter for Google Docs</title>
        <link rel="stylesheet" type="text/css" href="../css/output.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="../images/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="../images/favicon-16x16.png" />
    <link rel="manifest" href="../images/site.webmanifest" />
    </head>
    <body>
        <header>
  <div id="logo">
    <a href="../">David Han</a>
  </div>
</header>

        <main><article>
    <section class="header">
        <div class="text-sm font-mono text-slate-600">
            11 Dec 2024
        </div>
        <h1 class="my-1">Creating an Interpreter for Google Docs</h1>
    </section>
    <hr>
    <section>
        <h2 id="building-blocks">Building Blocks</h2>
<h3 id="google-apps-script">Google Apps Script</h3>
<p>This project was built entirely on Google Apps Script, a free code platform provided by Google. Google Apps Script and the Apps Script language (a subset of JavaScript) were created to provide inexperienced developers with <em>just</em> enough tools to create quick automations for Google Workspace products like Google Sheets.</p>
<p>While most Apps Script programmers make useful, practical things, I did the complete opposite and created a code interpreter for Google Docs. Because why use a “real” text editor like Neovim when you can add the same functionality to Google Docs? Who doesn’t want to double space their code?</p>
<h3 id="docaml">DOCaml</h3>
<p>In order to make an interpreter, we first need a programming language to interpret. To keep things simple, I decided to create a miniature version of OCaml called DOCaml.</p>
<h4 id="features">Features</h4>
<ul>
<li>Primitive types: String, Number, Bool</li>
<li>Binary mathematical operations (*, /, +. -)</li>
<li>Let expressions (variable bindings, function definitions)</li>
<li>Function applications</li>
<li>Line comments (Python/Ruby/R style)</li>
</ul>
<h3 id="creating-a-grammar-for-docaml">Creating a Grammar for DOCaml</h3>
<p>Like spoken or written languages, programming languages have grammars or rules that describe their structure. For example, when analyzing the sentence, “the child ran the race,” you can use grammatical conventions to derive its meaning:</p>
<figure>
<img src="../images/parsed-sentence.png" alt="Det = Determiner, NP = Noun Phrase, VP = Verb Phrase, S = Sentence" />
<figcaption aria-hidden="true">Det = Determiner, NP = Noun Phrase, VP = Verb Phrase, S = Sentence</figcaption>
</figure>
<p>In our case, DOCaml “sentences” are broken down like so:</p>
<figure>
<img src="../images/docaml-grammar.png" alt="DOCaml’s Grammar" />
<figcaption aria-hidden="true">DOCaml’s Grammar</figcaption>
</figure>
<p>Notice how expressions can be nested within other expressions? This kind of behavior makes the language more expressive and capable because there can be any number of subexpressions within a single expression.</p>
<p>Now that we have a grammar (a messy, imperfect grammar), we can focus on tokenizing it.</p>
<h3 id="lexing-aka-tokenizing">Lexing AKA Tokenizing</h3>
<p>Before transforming our plain text into a syntax tree, we have to divide it up into bite-sized pieces, or tokens that can be read by the parser. With plenty of regular expressions and conditionals, we can create a Google Apps Script program to turn our dirty code into a list of words that exist in DOCaml.</p>
<figure>
<img src="../images/docaml-lexer.png" alt="Lexer Test Output" />
<figcaption aria-hidden="true">Lexer Test Output</figcaption>
</figure>
<h3 id="parsing">Parsing</h3>
<p>To create an abstract syntax tree, the parser must iterate through the list of tokens, and construct statements based on token types.</p>
<p>If the parser was given the token list shown above, it would:</p>
<ol type="1">
<li>Create a new Program</li>
<li>Create a new Statement</li>
<li>Read the Let token, and begin constructing a Let expression</li>
<li>Ignore the equals symbol</li>
<li>Read the Number token</li>
<li>Finish constructing the Let expression</li>
<li>Return the complete tree → Program(Statement(Let(Var(x), Number(5))))</li>
</ol>
<p>Before moving onto the interpreter, it is important to address the possibility of “bad”, grammatically incorrect code. Without going into too much detail, assume that the parser will throw an error if it reads a token that breaks the rules defined by our grammar. Okay, now let’s move on.</p>
<figure>
<img src="../images/docaml-parser.png" alt="Parser Test Output" />
<figcaption aria-hidden="true">Parser Test Output</figcaption>
</figure>
<h3 id="interpreting">Interpreting</h3>
<p>Now that all of the necessary components have been implemented, the interpreter should be fairly easy to complete. During the execution of our program, we have to keep track of two things:</p>
<ol type="1">
<li>The result of the last statement to be executed</li>
<li>The environment that expressions are executed in</li>
</ol>
<p>The result of the last statement is simply the result returned by the entire program. The environment holds crucial information like variable bindings and function definitions, without it, the interpreter would not be able to “remember” anything.</p>
<p>If both requirements are fulfilled, the interpreter can just iterate through the syntax tree given by the parser and evaluate each statement in a program separately before returning the result of the final statement.</p>
<p>Hooray! Our DOCaml interpreter is now complete and ready to be deployed to Google Docs!</p>
<figure>
<img src="../images/docaml-interp.png" alt="Interpreter Test Output" />
<figcaption aria-hidden="true">Interpreter Test Output</figcaption>
</figure>
<h2 id="results">Results</h2>
<p>The source code for this project can be found in <a href="https://github.com/dhan4043/docaml">this repository</a>.
To keep things short, I am going to skip over the UI portion of this project, which is unimportant. Here are some neat little examples of DOCaml in action. Go make something fun!</p>
<figure>
<img src="../images/docaml-let.png" alt="Let Bindings" />
<figcaption aria-hidden="true">Let Bindings</figcaption>
</figure>
<figure>
<img src="../images/docaml-math.png" alt="Basic Math" />
<figcaption aria-hidden="true">Basic Math</figcaption>
</figure>
<figure>
<img src="../images/docaml-function.png" alt="Function Definition and Application" />
<figcaption aria-hidden="true">Function Definition and Application</figcaption>
</figure>
<figure>
<img src="../images/docaml-error.png" alt="Type Checking and Error Handling" />
<figcaption aria-hidden="true">Type Checking and Error Handling</figcaption>
</figure>
        
        Last modified 2025-7-23
        
    </section>
</article>
</main>
        <footer class="flex flex-col mt-12 mb-8 space-y-4">
    <div class="flex justify-center">
        <a aria-label="Link to Email" class="footer-icon" href="mailto:dhan4043@gmail.com">
            <i class="icon-mail"></i>
        </a>
        <a aria-label="Link to GitHub" class="footer-icon" href="https://github.com/dhan4043">
            <i class="icon-github"></i>
        </a>
    </div>
    <div class="text-center">
        Site generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
        Source on 
        <a href="https://github.com/dhan4043/haskell-profile">GitHub</a>.
    </div>
</footer>

    </body>
</html>
