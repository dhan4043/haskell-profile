---
title: Implementing a ROT13 Guessing Game in OCaml
date: 2023-12-12
last-edited: 2025-7-23
meta-img: /images/ocaml-logo.jpg
---

## What is ROT13?

There are many different ways to encrypt data in cryptography, but not all of them are equal in terms of complexity and hardness. One of the simplest encryption techniques is the **Caesar cipher**, named after Julius Caesar who used the method to conceal his private messages.<sup>1</sup> This rather primitive form of encryption is a type of **substitution cipher**, which obscures text through alphabetical shifts.

Take this plain quote for example:

> Eternity is a mere moment, just long enough for a joke.

If we replace each letter with the letter that appears three steps ahead of it in the English alphabet, we get something like this:

> Hwhuqlwb lv d phuh prphqw, mxvw orqj hqrxjk iru d mrnh.

Every “A” becomes a “D”
Every “E” becomes an “H”
And so on…

ROT13 is another version of the Caesar cipher that uses shifts, or ROTations, of 13.

Now it should be apparent that this encryption is incredibly easy to undo if you have the slightest hunch that it was used. Applying the same shift to a series of messages is like using one key for every unit in an apartment building. If an adversary can successfully decrypt even one message, then the entire conversation is compromised.

### So why should we care about ROT13?

While it is impractical to use ROT13 today, it is a relatively easy way to practice analyzing ciphertexts and looking for patterns within them. Encryption algorithms may seem magical and unbreakable, but the truth is, a decent portion of them rely on cute assumptions and plenty of faith.

## Gamifying ROT13

As a fun-_ish_ programming exercise, I wrote a basic OCaml program that:

1. Generates a quote
2. Encrypts it with ROT13
3. Asks the user to guess the original quote until they are correct or give up

### Generating Quotes

To generate quotes, we can use the Lwt module to make an HTTP request to the quotable API like so:

```ocaml
let fetch_quote () =
  let uri = Uri.of_string "https://api.quotable.io/random" in
  Client.get uri >>= fun (_, body) ->
  Cohttp_lwt.Body.to_string body
```

And to retrieve the quote + author information as text, we can use the Yojson module to parse the JSON response:

```ocaml
let fetch_quote () =
  let uri = Uri.of_string "https://api.quotable.io/random" in
  Client.get uri >>= fun (_, body) ->
  Cohttp_lwt.Body.to_string body

fetch_quote () >>= fun quote_json ->
	let quote = Yojson.Basic.from_string quote_json in
    let content = Yojson.Basic.Util.(quote |> member "content" |> to_string) in
    let author = Yojson.Basic.Util.(quote |> member "author" |> to_string) in
```

### Encrypting Quotes

Now that we have our hands on a good quote, we can start working on the encryption part of the program.
Instead of using a crypto library to generate ciphers, I decided to write the ROT13 function myself, since it has already been established that the algorithm is _very_ simple.

```ocaml
let rot13_char c =
  let base = if Char.code c >= Char.code 'a' then Char.code 'a' else Char.code 'A' in
  if Char.code c >= base && Char.code c <= base + 25 then
    Char.chr ((Char.code c - base + 13) mod 26 + base)
  else
    c
```

The function above applies ROT13 to a single character, and can easily be applied to a list of characters aka a string.

```ocaml
let rot13 str =
  String.map rot13_char str
```

### Guessing and Verification

To check if a user’s guess is correct, we can put a conditional in our main function to handle each attempt.

```ocaml
let rec guess_loop () =
      let guess = read_line () in
      if String.lowercase_ascii guess = "give up" then begin
        Printf.printf "%sThe original quote is:%s %s\n" bold reset content;
        Lwt.return ()
      end else if guess = content then begin
        Printf.printf "%sCongratulations! Your guess is correct!%s\n" green reset;
        Lwt.return ()
      end else if check_partial_guess content guess then begin
        Printf.printf "%sPartially Correct! Keep Going.%s\n" yellow reset;
        let regex = Str.regexp (rot13 guess) in
        let partial_quote = Str.replace_first regex guess encrypted_quote in
        Printf.printf "%sPartially Decrypted Quote:%s %s\n\n" bold reset (red ^ partial_quote ^ reset);
        guess_loop ()
      end else begin
        Printf.printf "%sIncorrect. Try again or type 'give up' to reveal the answer.%s\n" red reset;
        guess_loop ()
      end
    in
```

In the case that the user is only partially correct, we can replace the words that have been guessed (or calculated) correctly with their plaintext counterparts, and also leave all the other words alone.

```ocaml
let check_partial_guess original guess =
  let rec check_words orig_words guess_words partially_correct =
    match orig_words, guess_words with
    | [], [] -> partially_correct
    | _, [] -> partially_correct
    | o :: og, g :: gs ->
        if o = g then
          check_words og gs (partially_correct || true)
        else
          check_words og gs partially_correct
    | _, _ -> false
  in
  let orig_words = String.split_on_char ' ' original in
  let guess_words = String.split_on_char ' ' guess in
  check_words orig_words guess_words false
```

### Putting it all Together

Using all of the components above, we can finish making the game with just a pinch of boilerplate. The full main loop should look like this:

```ocaml
let main () =
  Lwt_main.run (
    fetch_quote () >>= fun quote_json ->
    let quote = Yojson.Basic.from_string quote_json in
    let content = Yojson.Basic.Util.(quote |> member "content" |> to_string) in
    let author = Yojson.Basic.Util.(quote |> member "author" |> to_string) in

    let encrypted_quote = rot13 content in
    Printf.printf "%sAuthor:%s %s\n" bold reset author;
    Printf.printf "%sEncrypted Quote:%s %s\n\n" bold reset (red ^ encrypted_quote ^ reset);
    print_endline "Can you guess the original quote? (Type your guess or 'give up' to reveal the answer)";

    let rec guess_loop () =
      let guess = read_line () in
      if String.lowercase_ascii guess = "give up" then begin
        Printf.printf "%sThe original quote is:%s %s\n" bold reset content;
        Lwt.return ()
      end else if guess = content then begin
        Printf.printf "%sCongratulations! Your guess is correct!%s\n" green reset;
        Lwt.return ()
      end else if check_partial_guess content guess then begin
        Printf.printf "%sPartially Correct! Keep Going.%s\n" yellow reset;
        let regex = Str.regexp (rot13 guess) in
        let partial_quote = Str.replace_first regex guess encrypted_quote in
        Printf.printf "%sPartially Decrypted Quote:%s %s\n\n" bold reset (red ^ partial_quote ^ reset);
        guess_loop ()
      end else begin
        Printf.printf "%sIncorrect. Try again or type 'give up' to reveal the answer.%s\n" red reset;
        guess_loop ()
      end
    in
    guess_loop ()
  )

let () = main ()
```

### The Final Result

Upon running the program, the user will be presented with a new encrypted quote that they can crack. Pretty neat! The source code for this mini project can be found [here]().

#### Example 1

![Example One](/images/ocaml-guesser-1.png)

#### Example 2

![Example Two](/images/ocaml-guesser-2.png)

## References

1. Suetonius. (n.d.). _SVETONI TRANQVILII VITA DIVI IVLI_. Divus Iulius. http://thelatinlibrary.com/suetonius/suet.caesar.html#56
2. Antoniyak . (2022, December 26). _OCaml 5 offers Shared memory support_. Devstyler.io. https://devstyler.io/blog/2022/12/26/ocaml-5-offers-shared-memory-support/
