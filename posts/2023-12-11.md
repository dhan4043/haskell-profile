---
title: Creating an Interpreter for Google Docs
---

## Building Blocks

### Google Apps Script

This project was built entirely on Google Apps Script, a free code platform provided by Google. Google Apps Script and the Apps Script language (a subset of JavaScript) were created to provide inexperienced developers with _just_ enough tools to create quick automations for Google Workspace products like Google Sheets.

While most Apps Script programmers make useful, practical things, I did the complete opposite and created a code interpreter for Google Docs. Because why use a "real" text editor like Neovim when you can add the same functionality to Google Docs? Who doesn’t want to double space their code?

### DOCaml

In order to make an interpreter, we first need a programming language to interpret. To keep things simple, I decided to create a miniature version of OCaml called DOCaml.

#### Features

- Primitive types: String, Number, Bool
- Binary mathematical operations (\*, \/, +. -)
- Let expressions (variable bindings, function definitions)
- Function applications
- Line comments (Python/Ruby/R style)

### Creating a grammar for DOCaml

Like spoken or written languages, programming languages have grammars or rules that describe their structure. For example, when analyzing the sentence, “the child ran the race,” you can use grammatical conventions to derive its meaning:

![Det = Determiner, NP = Noun Phrase, VP = Verb Phrase, S = Sentence](/images/parsed-sentence.png)

In our case, DOCaml “sentences” are broken down like so:

![DOCaml's Grammar](/images/docaml-grammar.png)

Notice how expressions can be nested within other expressions? This kind of behavior makes the language more expressive and capable because there can be any number of subexpressions within a single expression.

Now that we have a grammar (a messy, imperfect grammar), we can focus on tokenizing it.

### Lexing AKA tokenizing

Before transforming our plain text into a syntax tree, we have to divide it up into bite-sized pieces, or tokens that can be read by the parser. With plenty of regular expressions and conditionals, we can create a Google Apps Script program to turn our dirty code into a list of words that exist in DOCaml.

![Lexer Test Output](/images/docaml-lexer.png)

### Parsing

To create an abstract syntax tree, the parser must iterate through the list of tokens, and construct statements based on token types.

If the parser was given the token list shown above, it would:

1. Create a new Program
2. Create a new Statement
3. Read the Let token, and begin constructing a Let expression
4. Ignore the equals symbol
5. Read the Number token
6. Finish constructing the Let expression
7. Return the complete tree → Program(Statement(Let(Var(x), Number(5))))

Before moving onto the interpreter, it is important to address the possibility of “bad”, grammatically incorrect code. Without going into too much detail, assume that the parser will throw an error if it reads a token that breaks the rules defined by our grammar. Okay, now let’s move on.

![Parser Test Output](/images/docaml-parser.png)

### Interpreting

Now that all of the necessary components have been implemented, the interpreter should be fairly easy to complete. During the execution of our program, we have to keep track of two things:

1. The result of the last statement to be executed
2. The environment that expressions are executed in

The result of the last statement is simply the result returned by the entire program. The environment holds crucial information like variable bindings and function definitions, without it, the interpreter would not be able to “remember” anything.

If both requirements are fulfilled, the interpreter can just iterate through the syntax tree given by the parser and evaluate each statement in a program separately before returning the result of the final statement.

Hooray! Our DOCaml interpreter is now complete and ready to be deployed to Google Docs!

![Interpreter Test Output](/images/docaml-interp.png)

## Results

The source code for this project can be found in [this repository](https://github.com/dhan4043/docaml).
To keep things short, I am going to skip over the UI portion of this project, which is unimportant. Here are some neat little examples of DOCaml in action. Go make something fun!

![Let Bindings](/images/docaml-let.png)

![Basic Math](/images/docaml-math.png)

![Function Definition and Application](/images/docaml-function.png)

![Type Checking and Error Handling](/images/docaml-error.png)
